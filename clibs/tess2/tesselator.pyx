
#
# This file is autogenerated.
#


cimport tesselator_defs

from cython cimport view

TESS_UNDEF = tesselator_defs.TESS_UNDEF

cpdef enum TessWindingRule:
    TESS_WINDING_ODD=tesselator_defs.TESS_WINDING_ODD
    TESS_WINDING_NONZERO=tesselator_defs.TESS_WINDING_NONZERO
    TESS_WINDING_POSITIVE=tesselator_defs.TESS_WINDING_POSITIVE
    TESS_WINDING_NEGATIVE=tesselator_defs.TESS_WINDING_NEGATIVE
    TESS_WINDING_ABS_GEQ_TWO=tesselator_defs.TESS_WINDING_ABS_GEQ_TWO

cpdef enum TessElementType:
    TESS_POLYGONS=tesselator_defs.TESS_POLYGONS
    TESS_CONNECTED_POLYGONS=tesselator_defs.TESS_CONNECTED_POLYGONS
    TESS_BOUNDARY_CONTOURS=tesselator_defs.TESS_BOUNDARY_CONTOURS

cdef class Tesselator:
    cdef const tesselator_defs.TESStesselator * _this_ptr
    cdef int _polySize
    cdef int _vertexSize
    cdef TessElementType _elementType
    
    property element_count:
        def __get__(self):
            return tesselator_defs.tessGetElementCount(self._this_ptr)

    property vertex_count:
        def __get__(self):
            return tesselator_defs.tessGetVertexCount(self._this_ptr)
    
    property elements:
        def __get__(self):
            assert self._polySize
            cdef:
                size_t i, j
                int count = self.element_count
                const int* elements = tesselator_defs.tessGetElements(self._this_ptr)
                const int* element
            result = []
            for i in range(count):
                if self._elementType == TESS_POLYGONS:
                    element = &elements[i * self._polySize]
                    result.append([element[j] for j in range(self._polySize)])
                elif self._elementType == TESS_BOUNDARY_CONTOURS:
                    element = &elements[i * 2]
                    result.append([element[j] for j in range(2)])
                else:
                    raise NotImplemented
            return result
    
    property vertices:
        def __get__(self):
            assert self._vertexSize
            cdef:
                size_t i, j
                int count = self.vertex_count
                const float* vertices = tesselator_defs.tessGetVertices(self._this_ptr)
                const float* vertex
            result = []
            for i in range(count):
                vertex = &vertices[i * self._vertexSize]
                result.append([vertex[j] for j in range(self._vertexSize)])
            return result
    
    def __cinit__(self):
        self._this_ptr = tesselator_defs.tessNewTess(NULL)
        self._polySize = 0
        self._vertexSize = 0
        self._elementType = TESS_POLYGONS
        
    def __dealloc__(self):
        tesselator_defs.tessDeleteTess(self._this_ptr)
        self._this_ptr = NULL
    
    def __iter__(self):
        assert self._polySize and self._vertexSize
        elements = self.elements
        vertices = self.vertices
        if self._elementType == TESS_POLYGONS:
            for element in self.elements:
                yield [vertices[index] for index in element if index != TESS_UNDEF]
        elif self._elementType == TESS_BOUNDARY_CONTOURS:
            for element in self.elements:
                yield [vertices[index] for index in range(element[0], element[1])]
        else:
            raise NotImplemented
    
    cpdef add_contour(self, contour):
        cdef:
            size_t i, j
            float[:,::1] data
            int size
            int stride
            int count
    
        if isinstance(contour, (tuple, list)):
            shape = (len(contour), len(contour[0]))
            data = view.array(shape=shape, itemsize=sizeof(float), format="f")
            for i in range(shape[0]):
                for j in range(shape[1]):
                    data[i,j] = contour[i][j]
        else:
            # must be a memory view or a buffer type
            data = contour
        
        size = data.shape[1]
        stride = data.strides[0]
        count = data.shape[0]
        
        tesselator_defs.tessAddContour(self._this_ptr, size, <void *>&data[0,0], stride, count)
    
    cpdef int tesselate(self, TessWindingRule windingRule=TESS_WINDING_ODD, TessElementType elementType=TESS_POLYGONS, int polySize=3, int vertexSize=3):
        self._polySize = polySize
        self._vertexSize = vertexSize
        self._elementType = elementType
        return tesselator_defs.tessTesselate(self._this_ptr, windingRule, elementType, self._polySize, self._vertexSize, NULL)
        
    def __richcmp__(Tesselator self, Tesselator other, int op):
        if op == 0:
            # <
            return self._this_ptr < other._this_ptr
        elif op == 1:
            # <=
            return self._this_ptr <= other._this_ptr
        elif op == 2:
            # ==
            return self._this_ptr == other._this_ptr
        elif op == 3:
            # !=
            return self._this_ptr != other._this_ptr
        elif op == 4:
            # >
            return self._this_ptr > other._this_ptr
        elif op == 5:
            # >=
            return self._this_ptr >= other._this_ptr
    
    def __hash__(self):
        return <size_t>self._this_ptr
