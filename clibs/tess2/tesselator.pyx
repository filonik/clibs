
#
# This file is autogenerated.
#

cimport c_tesselator

	#
	# Defines:
	#

TESS_UNDEF = c_tesselator.TESS_UNDEF

	#
	# Supplements:
	#


from cython cimport view

from enum import IntEnum

class WindingRule(IntEnum):
    ODD=c_tesselator.TESS_WINDING_ODD
    NONZERO=c_tesselator.TESS_WINDING_NONZERO
    POSITIVE=c_tesselator.TESS_WINDING_POSITIVE
    NEGATIVE=c_tesselator.TESS_WINDING_NEGATIVE
    ABS_GEQ_TWO=c_tesselator.TESS_WINDING_ABS_GEQ_TWO

class ElementType(IntEnum):
    POLYGONS=c_tesselator.TESS_POLYGONS
    CONNECTED_POLYGONS=c_tesselator.TESS_CONNECTED_POLYGONS
    BOUNDARY_CONTOURS=c_tesselator.TESS_BOUNDARY_CONTOURS

cdef class Tesselator:
    property element_count:
        def __get__(self):
            return c_tesselator.tessGetElementCount(self._this)

    property vertex_count:
        def __get__(self):
            return c_tesselator.tessGetVertexCount(self._this)
    
    property elements:
        def __get__(self):
            assert self._polySize
            cdef:
                size_t i, j
                int count = self.element_count
                const int* elements = c_tesselator.tessGetElements(self._this)
                const int* element
            result = []
            for i in range(count):
                if self._elementType == c_tesselator.TESS_POLYGONS:
                    element = &elements[i * self._polySize]
                    result.append([element[j] for j in range(self._polySize)])
                elif self._elementType == c_tesselator.TESS_BOUNDARY_CONTOURS:
                    element = &elements[i * 2]
                    result.append([element[j] for j in range(2)])
                else:
                    raise NotImplemented
            return result
    
    property vertices:
        def __get__(self):
            assert self._vertexSize
            cdef:
                size_t i, j
                int count = self.vertex_count
                const float* vertices = c_tesselator.tessGetVertices(self._this)
                const float* vertex
            result = []
            for i in range(count):
                vertex = &vertices[i * self._vertexSize]
                result.append([vertex[j] for j in range(self._vertexSize)])
            return result
    
    def __cinit__(self):
        self._this = c_tesselator.tessNewTess(NULL)
        self._polySize = 0
        self._vertexSize = 0
        self._elementType = c_tesselator.TESS_POLYGONS
        
    def __dealloc__(self):
        c_tesselator.tessDeleteTess(self._this)
        self._this = NULL
    
    def __iter__(self):
        assert self._polySize and self._vertexSize
        elements = self.elements
        vertices = self.vertices
        if self._elementType == c_tesselator.TESS_POLYGONS:
            for element in self.elements:
                yield [vertices[index] for index in element if index != TESS_UNDEF]
        elif self._elementType == c_tesselator.TESS_BOUNDARY_CONTOURS:
            for element in self.elements:
                yield [vertices[index] for index in range(element[0], element[1])]
        else:
            raise NotImplemented
    
    cpdef add_contour(self, contour):
        cdef:
            size_t i, j
            float[:,:] data
            int size
            int stride
            int count
    
        if isinstance(contour, (tuple, list)):
            shape = (len(contour), len(contour[0]))
            data = view.array(shape=shape, itemsize=sizeof(float), format="f")
            for i in range(shape[0]):
                for j in range(shape[1]):
                    data[i,j] = contour[i][j]
        else:
            # must be a memory view or a buffer type
            data = contour
        
        size = data.shape[1]
        stride = data.strides[0]
        count = data.shape[0]
        
        c_tesselator.tessAddContour(self._this, size, <void *>&data[0,0], stride, count)
    
    cpdef int tesselate(self, windingRule=c_tesselator.TESS_WINDING_ODD, elementType=c_tesselator.TESS_POLYGONS, int polySize=3, int vertexSize=3):
        self._polySize = polySize
        self._vertexSize = vertexSize
        self._elementType = elementType
        return c_tesselator.tessTesselate(self._this, windingRule, elementType, self._polySize, self._vertexSize, NULL)
        
    def __richcmp__(Tesselator self, Tesselator other, int op):
        if op == 0:
            # <
            return self._this < other._this
        elif op == 1:
            # <=
            return self._this <= other._this
        elif op == 2:
            # ==
            return self._this == other._this
        elif op == 3:
            # !=
            return self._this != other._this
        elif op == 4:
            # >
            return self._this > other._this
        elif op == 5:
            # >=
            return self._this >= other._this
    
    def __hash__(self):
        return <size_t>self._this
